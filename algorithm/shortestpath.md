# Graph-Shortest-Path


Reference: http://blog.csdn.net/henryczj/article/details/37830623

  - floyd
    — 每对顶点之间的最短路径，动态规划方法， 三重循环， k在最外层，算法的时间复杂度为O(V3)，其中V是图中顶点个数
    — 需要注意的是Floyd-Warshall算法同样不适用于带负权的回路，但可以允许有负权。说到这里，我们自然会问，Floyd-Warshall算法如何来判断图中是否有负权回路？这里有一种方式如下：当执行完该算法后，会得到一个最终的结果邻接矩阵，我们只需判断结果邻接矩阵的主对角线的元素是否有为负值的，如果有，则该图存在负权回路，如果没有，则说明该图不存在负权回路。
  -  dijkstra
    -【贪心策略。算法初始时设置了一个顶点集合S，该集合最开始为空。然后初始化源点s到图中各点的最短路径估计值，记作d[v]，其中v为除源点以外的任意点。初始时d[s]=0，其它点的d值均为正无穷大。d值的维护用到了最小优先队列。算法每次选择d值最小的点，然后将该点加入集合S，并对该点的所有出边进行松弛。】
    —有向/无向图 非负权 A到B最短路径：  找点
  - bellman-ford
     — 求解带有负权但不含负权回路的单源最短路径
     — 检查图中是否含有源点可达的负权回路
  - SPFA
     — Shortest Path Faster Algorithm）。该算法用一个队列作为优化，减少了冗余的松弛操作，从而改进了Bellman-Ford算法的时间复杂度

### Question
##### 1.题目：套汇问题。该问题的描述是：利用货币汇率的差异，把一个单位的某种货币转换为大于一个单位的同种货币的方法。比如，假定1美元可以买46.4印度卢比，1印度卢比可以买2.5日元，1日元可以买0.0091美元。通过货币兑换，一个商人可以从1美元开始买入，得到46.4*2.5*0.0091=1.0556美元，因而获利5.56%。
给定一系列货币以及它们之间的汇率，从某种货币开始，能否经过一系列的货币兑换得到的钱数大于这种货币。
这样一来，问题转化成在一个有向图中，判断是否存在从源货币可达的正权回路，如果有这样的回路，那么货币在这个正权回路中将持续增值，最终再兑换回源货币时，可以实现增值。


## TODO
1.code
2.证明算法正确性